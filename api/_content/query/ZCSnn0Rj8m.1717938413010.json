{"_path":"/blog/introduction-to-homomorphic-encryption","_dir":"blog","_draft":false,"_partial":false,"_locale":"","title":"Introduction to Homomorphic Encryption","description":"This is the first of a series of blog posts about the use of homomorphic encryption for deep learning. Here I introduce the basics and terminology as well as link to external resources that might help with a deeper understanding of the topic.","date":"2020-01-02T00:00:00.000Z","image":"/img/he-1.jpg","draft":false,"body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This is the first of a series of blog posts about the use of homomorphic encryption for deep learning. Here I introduce the basics and terminology as well as link to external resources that might help with a deeper understanding of the topic. I also wrap-up with challenges of applying HE to DL that I should discuss in later blog posts."}]},{"type":"element","tag":"h2","props":{"id":"introduction"},"children":[{"type":"text","value":"Introduction"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A breakthrough in the history of cryptography was the "},{"type":"element","tag":"a","props":{"href":"https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"introduction of the first fully homomorphic scheme"}]},{"type":"text","value":" by Craig Gentry in 2009, however, the scheme wasn't practical at that time, so many researchers and engineers were putting efforts to making such scheme practical in industries where privacy is a big concern. Since then many researches have been done to improve performance, "},{"type":"element","tag":"a","props":{"href":"https://www.microsoft.com/en-us/research/project/microsoft-seal/","rel":["nofollow"]},"children":[{"type":"text","value":"many"}]},{"type":"text","value":" "},{"type":"element","tag":"a","props":{"href":"https://github.com/snucrypto/HEAAN","rel":["nofollow"]},"children":[{"type":"text","value":"open source"}]},{"type":"text","value":" "},{"type":"element","tag":"a","props":{"href":"https://tfhe.github.io/tfhe/","rel":["nofollow"]},"children":[{"type":"text","value":"tools"}]},{"type":"text","value":" "},{"type":"element","tag":"a","props":{"href":"https://github.com/shaih/HElib","rel":["nofollow"]},"children":[{"type":"text","value":"have"}]},{"type":"text","value":" "},{"type":"element","tag":"a","props":{"href":"https://github.com/vernamlab/cuFHE","rel":["nofollow"]},"children":[{"type":"text","value":"been"}]},{"type":"text","value":" "},{"type":"element","tag":"a","props":{"href":"https://github.com/CryptoExperts/FV-NFLlib","rel":["nofollow"]},"children":[{"type":"text","value":"released"}]},{"type":"text","value":", and papers have been published showing how practical HE has become in the case of "},{"type":"element","tag":"a","props":{"href":"https://eprint.iacr.org/2018/074.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"logistic regression"}]},{"type":"text","value":", as well as "},{"type":"element","tag":"a","props":{"href":"http://proceedings.mlr.press/v48/gilad-bachrach16.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"deep learning"}]},{"type":"text","value":". We also hope to see tools that lower the barrier of applying homomorphic encryption in deep learning. But let's first take a look at what HE is."}]},{"type":"element","tag":"h2","props":{"id":"black-box-view"},"children":[{"type":"text","value":"Black Box View"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Say we have a function F that performs a certain computation on two elements x and y and outputs a result z : "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"z = F(x, y)"}]},{"type":"text","value":", an HE scheme lets you perform a certain function (we use the same F in our case) on encrypted elements "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"he_encrypt(F(x, y)) = F(he_encrypt(x), he_encrypt(y))"}]},{"type":"text","value":". That function F is generally an addition or a multiplication, having a scheme that supports arbitrary function F is a dream at the time of writing this post (but who knows?), which resulted in some challenges we will discuss later on."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"he black box","src":"/img/he-black-box.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So, what do we get from all this? Well, let's say that you want to perform some computation in the cloud using some data, but still want to preserve its privacy, using HE you can send the encrypted version of your data to the cloud, perform the computation there and get back the encrypted result that you can decrypt later on. All these steps don't require the client to stay connected (to provide additional help during the computation) and that's one benefit of HE."}]},{"type":"element","tag":"h2","props":{"id":"more-details"},"children":[{"type":"text","value":"More Details"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Like any encryption, HE schemes use a public key to encrypt plaintexts into ciphertexts, and a secret or private key to decrypt ciphertexts into plaintexts, optionally, they may use an evaluation key to perform operations (addition/multiplication) on ciphertexts."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"he process","src":"/img/he-process.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HE schemes (here I'm talking about the ones that are based on lattices and the RLWE problem) operate in similar manners where they hide the plaintext by adding a secret part that can be taken off using only the secret key plus a noise that doesn't affect decryption, however, some issues arise when this noise gets multiplied or added with other noises while performing evaluations on ciphertexts, we will not go into the details here but you should keep in mind this when you choose parameters for your schemes and how to make sure the noise doesn't completely blind your plaintext."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I will dedicate a blog post to talk more about "},{"type":"element","tag":"a","props":{"href":"https://eprint.iacr.org/2016/421.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"the CKKS scheme"}]},{"type":"text","value":" and how it can be used in practice using the "},{"type":"element","tag":"a","props":{"href":"https://github.com/Microsoft/SEAL","rel":["nofollow"]},"children":[{"type":"text","value":"Microsoft SEAL library"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h2","props":{"id":"types-of-he"},"children":[{"type":"text","value":"Types of HE"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Depending on the possible functions F you can compute and how many operations can be chained on a ciphertext, HE schemes can be classified into 3 main types:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Fully-HE (FHE)"}]},{"type":"text","value":": That's the most useful type to be used for deep learning currently, it allows any number of addition and multiplication operations."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Somewhat-HE (SHE)"}]},{"type":"text","value":": It allows both addition and multiplication, but we are limited in term of the number of operations we can perform."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Partially-HE (PHE)"}]},{"type":"text","value":": This type of scheme either allows addition or multiplication, but in an unlimited fashion."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I have dedicated a blog post that you can find "},{"type":"element","tag":"a","props":{"href":"/blog/homomorphic-encryption-types/"},"children":[{"type":"text","value":"here"}]},{"type":"text","value":" that details more about each type."}]},{"type":"element","tag":"h2","props":{"id":"about-the-security-of-he-schemes"},"children":[{"type":"text","value":"About the Security of HE Schemes"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If you are concerned with the security of HE schemes, and how broken they can be in the near future, then you should know that most current schemes use "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Lattice-based_cryptography","rel":["nofollow"]},"children":[{"type":"text","value":"lattice-based cryptography"}]},{"type":"text","value":" which is post-quantum secure. If those words doesn't make sense to you then just keep in mind that there is no algorithm that can break the security of this kind of schemes in polynomial time both in classical and quantum computers, actually, the best known attack runs in exponential time. For more details on how to set parameters to achieve a certain security level, please refer to the Homomorphic Encryption Standard listed in the "},{"type":"element","tag":"a","props":{"href":"#additional-resources"},"children":[{"type":"text","value":"Additional Resources section"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h2","props":{"id":"challenges-of-applying-he-for-deep-learning"},"children":[{"type":"text","value":"Challenges of Applying HE for Deep Learning"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Most of deep neural networks operations are tensor multiplication and nonlinear activation functions, the former is natively supported by HE schemes, but the latter is not, functions like "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Sigmoid_function","rel":["nofollow"]},"children":[{"type":"text","value":"sigmoid"}]},{"type":"text","value":" can't be simply applied on encrypted data, however, they can be approximated using a linear function, we can use low degree polynomials to do that, of course there is a tradeoff between precision and performance, you get better precision when you choose a higher degree polynomial but you will also need to do more computation which is something you should care about when doing HE, in general, you should choose the lowest degree polynomial that has a good precision on a range "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"a, b"}]},{"type":"text","value":" that most of your data fall into."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Deep neural networks also involve a long chain of multiplications which is hard to do with practical schemes (which are basically SHE), we can't apply many multiplications to ciphertexts and still be able to decrypt to the correct value, possible solutions would be to send back ciphertexts to the data owner at some point to be decrypted, re-encrypted and sent back so further multiplications can be done, this requires an active connection with the client which isn't always possible. We can also either adapt the parameters of our scheme to make a certain multiplicative depth possible or use "},{"type":"element","tag":"a","props":{"href":"https://crypto.stackexchange.com/questions/42666/what-exactly-is-bootstrapping-in-fhe","rel":["nofollow"]},"children":[{"type":"text","value":"bootstrapping"}]},{"type":"text","value":", which can allow any multiplicative depth and thus transforming SHE schemes into FHE, however, bootstrapping operations are costly but "},{"type":"element","tag":"a","props":{"href":"https://eprint.iacr.org/2018/1043.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"some work"}]},{"type":"text","value":"s are trying to make it more practical."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A single ciphertext in "},{"type":"element","tag":"a","props":{"href":"https://eprint.iacr.org/2016/421.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"the CKKS scheme"}]},{"type":"text","value":" (and many others) can hold more than a simple number, so someone can increase efficiency by batching a vector into a single ciphertext thus multiplying all the value in the vector with a single instruction (SIMD: Single Instruction Multiple Data), this will also reduce both memory consumption (doesn't require to hold N ciphertexts) and communication costs (as we send and get back ciphertexts to the cloud), however, batching introduces complexity in how to handle operations, for instance, if we put a whole vector into a ciphertext then how should we do dot product operations? Designing a good structure for tensors here is key to make HE practical in deep learning."}]},{"type":"element","tag":"h2","props":{"id":"conclusion"},"children":[{"type":"text","value":"Conclusion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Only a decade after introducing the first FHE scheme and we have seen practical application of it, of course, there is still room for improvements and for things to become standardized and production-ready, but let's hope for the best and build solutions that make privacy a trivial thing."}]},{"type":"element","tag":"h2","props":{"id":"additional-resources"},"children":[{"type":"text","value":"Additional Resources"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.n1analytics.com/homomorphic-encryption-illustrated-primer/","rel":["nofollow"]},"children":[{"type":"text","value":"A Homomorphic Encryption Illustrated Primer"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://homomorphicencryption.org/wp-content/uploads/2018/11/HomomorphicEncryptionStandardv1.1.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"Homomorphic Encryption Standard"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.microsoft.com/en-us/research/event/private-ai-bootcamp/","rel":["nofollow"]},"children":[{"type":"text","value":"Microsoft Private AI Bootcamp, Dec 2019"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"introduction","depth":2,"text":"Introduction"},{"id":"black-box-view","depth":2,"text":"Black Box View"},{"id":"more-details","depth":2,"text":"More Details"},{"id":"types-of-he","depth":2,"text":"Types of HE"},{"id":"about-the-security-of-he-schemes","depth":2,"text":"About the Security of HE Schemes"},{"id":"challenges-of-applying-he-for-deep-learning","depth":2,"text":"Challenges of Applying HE for Deep Learning"},{"id":"conclusion","depth":2,"text":"Conclusion"},{"id":"additional-resources","depth":2,"text":"Additional Resources"}]}},"_type":"markdown","_id":"content:blog:introduction-to-homomorphic-encryption.md","_source":"content","_file":"blog/introduction-to-homomorphic-encryption.md","_extension":"md"}